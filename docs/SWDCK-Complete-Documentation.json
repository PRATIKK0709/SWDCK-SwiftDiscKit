{
  "project": "SWDCK",
  "pages": [
    {
      "id": "01",
      "filename": "01-introduction.md",
      "title": "01 Introduction",
      "content": "# Introduction & Overview\n\n**SWDCK** (SwiftDiscKit) is a high-performance, modern Discord bot framework written entirely in Swift. It leverages Swift's powerful concurrency model (`async/await`) to provide a seamless and efficient developer experience for building everything from simple notification bots to complex, interactive community tools.\n\nBuilt from the ground up to be lightweight yet feature-rich, SWDCK handles the complexities of the Discord Gateway and REST API, allowing you to focus on your bot's unique logic.\n\n## Why use SWDCK?\n\nCompared to other Discord libraries in the Swift ecosystem, SWDCK prioritizes:\n\n- **Modern Swift Concurrency**: Fully built on `async/await` and `Actors`, ensuring thread safety and readable asynchronous code.\n- **Type Safety**: Comprehensive models for Discord entities (Messages, Interactions, Guilds, etc.) reduce runtime errors.\n- **Developer Productivity**: A clean, intuitive API that feels \"Swifty\" and follows modern best practices.\n- **Rich Interaction Support**: First-class support for Slash Commands and the powerful \"Components V2\" system.\n\n## Feature Highlights\n\n| Feature | Description |\n|---------|-------------|\n| **Gateway Support** | Automatic connection management, heartbeat, and reconnection logic. |\n| **Slash Commands** | Easy registration and handling of global and guild-scoped commands. |\n| **Event System** | Type-safe closures for handling messages, member updates, and more. |\n| **Components V2** | Support for modern UI elements like buttons, select menus, and modals. |\n| **Rich Embeds** | A flexible builder for creating beautiful, formatted messages. |\n| **Full API Mapping** | Access to almost every Discord REST endpoint via a clean interface. |\n\n## Requirements\n\nTo build and run a bot with SWDCK, you'll need:\n\n- **Swift Version**: 5.9 or higher\n- **Platform**: macOS 14.0+ or iOS 17.0+\n- **Discord API**: v10 (handled automatically by the library)\n\n---\n\n## Documentation Map\n\n- [Installation](./installation) \u2014 Get set up and connected.\n- [Quick Start](./quick-start) \u2014 Your first \"Hello World\" bot.\n- [Core Concepts](./core-concepts) \u2014 Understanding the SWDCK mental model.\n- [Event System](./event-system) \u2014 Listen and react to Discord events.\n- [Messages](./messages) \u2014 Reading and sending messages.\n- [Embeds](./embeds) \u2014 Creating rich, formatted content.\n- [Slash Commands](./slash-commands) \u2014 Modern interactions.\n- [Components](./components) \u2014 Buttons, Selects, and Modals.\n- [API Reference](./api-reference) \u2014 Exhaustive technical documentation.\n\n> **Next:** [Installation](./installation)\n"
    },
    {
      "id": "02",
      "filename": "02-installation.md",
      "title": "02 Installation",
      "content": "# Installation\n\nSet up your development environment and get SWDCK added to your project.\n\n## Prerequisites\n\nBefore diving in, ensure you have the following:\n\n- **Xcode 15.0** or later.\n- **Swift 5.9** or later.\n- A **Discord Account** and access to the [Discord Developer Portal](https://discord.com/developers/applications).\n\n## Discord Setup\n\n### 1. Create an Application\n1. Go to the [Discord Developer Portal](https://discord.com/developers/applications).\n2. Click **New Application** and give it a name.\n3. On the left sidebar, click **Bot**.\n4. Click **Reset Token** (or **Copy Token**) to get your bot token. \n   > \u26a0\ufe0f **Warning:** Keep this token secret! Anyone with it can control your bot.\n\n### 2. Enable Privileged Intents\nFor your bot to receive messages or track member updates, you must enable specific **Intents**:\n1. In the **Bot** tab of your application, scroll down to **Privileged Gateway Intents**.\n2. Enable **MESSAGE CONTENT INTENT** (required for reading message content).\n3. Enable **GUILD MEMBERS INTENT** (if you need to track members).\n4. Click **Save Changes**.\n\n### 3. Invite the Bot\n1. Go to **OAuth2** -> **URL Generator**.\n2. Select the `bot` and `applications.commands` scopes.\n3. Select the permissions your bot needs (e.g., `Send Messages`, `Use Slash Commands`).\n4. Copy the generated URL and open it in your browser to invite the bot to your server.\n\n---\n\n## Swift Package Manager Setup\n\nSWDCK is distributed as a Swift Package. You can add it via Xcode or your `Package.swift` file.\n\n### Via Xcode\n1. Open your project in Xcode.\n2. Select **File > Add Package Dependencies...**\n3. Enter the repository URL: `https://github.com/PRATIKK0709/SWDCK--SwiftDiscKit`\n4. Set the Dependency Rule to **Branch: main** (or a specific version if available).\n5. Select the `SWDCK` library and click **Add Package**.\n\n### Via Package.swift\nAdd the dependency to your `Package.swift` file:\n\n```swift\n// swift-tools-version: 5.9\nimport PackageDescription\n\nlet package = Package(\n    name: \"MyBot\",\n    dependencies: [\n        .package(url: \"https://github.com/PRATIKK0709/SWDCK--SwiftDiscKit\", branch: \"main\")\n    ],\n    targets: [\n        .executableTarget(\n            name: \"MyBot\",\n            dependencies: [\n                .product(name: \"SWDCK\", package: \"SWDCK\")\n            ]\n        )\n    ]\n)\n```\n\n## Verifying Installation\n\nTry to import the library in your main file to ensure everything is linked correctly:\n\n```swift\nimport SWDCK\n\nprint(\"SWDCK is ready!\")\n```\n\n> \ud83d\udca1 **Tip:** If you encounter build errors, double-check that your target platform is set to macOS 14.0+ or iOS 17.0+.\n\n> **Next:** [Quick Start: Your First Bot](./quick-start)\n"
    },
    {
      "id": "03",
      "filename": "03-quick-start.md",
      "title": "03 Quick Start",
      "content": "# Quick Start: Your First Bot\n\nGet your first bot online in minutes. This \"Hello World\" example creates a bot that responds to a `!ping` command with `Pong!`.\n\n## The \"Hello World\" Bot\n\nCreate a new Swift file (e.g., `main.swift`) and paste the following code:\n\n```swift\nimport SWDCK\nimport Foundation\n\n// 1. Initialize the bot with your secret token\n// Ensure you have enabled the MESSAGE_CONTENT intent in the developer portal!\nlet bot = DiscordBot(\n    token: \"YOUR_BOT_TOKEN_HERE\",\n    intents: .default | .messageContent // Include required intents\n)\n\n// 2. Register a handler for the 'messageCreate' event\nbot.onMessage { message in\n    // 3. Ignore messages from other bots (and yourself!)\n    guard !message.author.bot else { return }\n    \n    // 4. Check if the message content is \"!ping\"\n    if message.content.lowercased() == \"!ping\" {\n        // 5. Send a reply back to the same channel\n        try await message.reply(\"Pong! \ud83c\udfd3\")\n        print(\"Responded to ping from \\(message.author.username)\")\n    }\n}\n\n// 6. Connect to the Discord Gateway\ntry await bot.start()\n```\n\n## Explaining the Code\n\n- **`DiscordBot(token:intents:)`**: The heart of your bot. It takes your token and a set of **Intents** (permissions to receive certain data from Discord).\n- **`onMessage`**: A high-level event listener that fires whenever a new message is sent in a channel the bot can see.\n- **`guard !message.author.bot`**: Crucial best practice! This prevents infinite loops where your bot reacts to its own messages or other bots.\n- **`message.reply(_:)`**: A convenient helper that sends a message back to the same channel, referencing the original message.\n- **`bot.start()`**: Connects to Discord and keeps the process running to listen for events.\n\n## How to Run It\n\n1. **Replace** `\"YOUR_BOT_TOKEN_HERE\"` with your actual token from the Developer Portal.\n2. **Terminal**: If using the command line, run `swift run`.\n3. **Xcode**: Simply click the **Play** button.\n\n### What to expect\nOnce running, you should see a log message saying `Gateway IDENTIFY` and eventually `Bot ready!`. Go to your Discord server and type `!ping` \u2014 your bot should instantly respond with `Pong!`.\n\n## Common First-Run Errors\n\n#### \u2753 The bot comes online but doesn't respond\n**Likely Cause:** You forgot to enable the **Message Content Intent** in the Discord Developer Portal or forgot to include `.messageContent` in your `GatewayIntents`.\n\n#### \u2753 `Invalid Token` error\n**Likely Cause:** Your token is incorrect or has been reset. Double-check it in the portal.\n\n> **Next:** [Core Concepts](./core-concepts)\n"
    },
    {
      "id": "04",
      "filename": "04-core-concepts.md",
      "title": "04 Core Concepts",
      "content": "# Core Concepts\n\nBefore building complex features, it's important to understand the mental model behind SWDCK and how it interacts with Discord.\n\n## The `DiscordBot` Object\n\nThe `DiscordBot` class is the central hub of your application. It manages the connection to Discord, handles incoming events, and providing access to the REST API. You typically create one instance of this class and use it throughout your bot's lifecycle.\n\n```swift\nlet bot = DiscordBot(token: \"...\", intents: .default)\n```\n\n## Token\n\nA **Bot Token** is essentially your bot's password. SWDCK uses it to authenticate every request made to Discord. \n> \u26a0\ufe0f **Warning:** Never hardcode your token in public repositories. Use environment variables or a configuration file instead.\n\n## Intents\n\n**Intents** are a way for your bot to tell Discord exactly which events it wants to receive. This reduces bandwidth and improves performance.\n- `.default`: Includes common events like guild joins, channel updates, etc.\n- `.messageContent`: Required to read the `content` of messages.\n- `.guildMembers`: Required to receive member-related events (privileged).\n\n```swift\n// Example: Subscribing to default events + message content\nlet intents = GatewayIntents.default | .messageContent\n```\n\n## Gateway\n\nThe **Gateway** is a long-lived WebSocket connection that Discord uses to send real-time events to your bot. SWDCK manages this connection for you, including:\n- **Handshaking**: Identifying your bot to Discord.\n- **Heartbeating**: Periodically telling Discord the bot is still alive.\n- **Resuming**: Automatically reconnecting if the connection drops.\n\n## Async/Await\n\nSWDCK is built from the ground up using modern Swift concurrency. Almost every method that interacts with Discord is `async` and capable of `throwing` errors. This ensures your bot remains responsive and handles network failures gracefully.\n\n```swift\n// Everything is async and thread-safe\ntry await bot.sendMessage(to: \"channel_id\", content: \"Hello!\")\n```\n\n## Event-Driven Architecture\n\nInstead of constantly asking Discord \"Is there a new message?\", your bot registers **Handlers** for specific events. When an event occurs, Discord sends it to SWDCK, which then executes your code.\n\n```swift\nbot.onMessage { message in \n    print(\"Received: \\(message.content)\")\n}\n```\n\n## Caching\n> \ud83d\udeab **Not supported:** SWDCK does not currently implement built-in caching for guilds, members, or channels. Every piece of data is provided directly from the Discord event or requested via the REST API.\n\n> **Next:** [Event System](./event-system)\n"
    },
    {
      "id": "05",
      "filename": "05-event-system.md",
      "title": "05 Event System",
      "content": "# Event System\n\nSWDCK uses an event-driven model. Your bot waits for \"Dispatch\" events from Discord (like a new message, a user joining, or a reaction) and reacts to them using registered handlers.\n\n## Registering Event Handlers\n\nYou register handlers using specific methods on the `DiscordBot` object. Each method takes a closure that is executed when the event occurs.\n\n```swift\nbot.onReady { readyData in\n    print(\"Bot is online as \\(readyData.user.username)\")\n}\n\nbot.onMessage { message in\n    print(\"New message: \\(message.content)\")\n}\n```\n\n## Async Event Handlers\n\nAll event handlers in SWDCK are **asynchronous**. This means you can perform network requests or other async operations directly inside the handler without blocking the rest of the bot.\n\n```swift\nbot.onMessage { message in\n    // You can call async methods here\n    try await message.reply(\"I received your message!\")\n}\n```\n\n## How Multiple Handlers Work\n\n> \u26a0\ufe0f **Needs verification:** Currently, calling an event registration method multiple times (e.g., calling `onMessage` twice) will **overwrite** the previous handler. It is recommended to have a single entry point for each event type and delegate the logic internally if needed.\n\n## Event Reference Table\n\n| Event Method | When It Fires | Payload Type | Key Fields |\n|--------------|--------------|--------------|------------|\n| `onReady` | Bot successfully connected and identified. | `ReadyData` | `user`, `guilds`, `sessionId` |\n| `onMessage` | A new message is created. | `Message` | `content`, `author`, `channelId` |\n| `onMessageUpdate` | A message is edited. | `Message` | `id`, `content`, `channelId` |\n| `onMessageDelete` | A message is deleted. | `MessageDelete` | `id`, `channelId`, `guildId` |\n| `onInteraction` | A slash command or component is used. | `Interaction` | `type`, `data`, `token` |\n| `onGuildCreate` | Bot joins a guild or guild becomes available. | `Guild` | `id`, `name`, `roles` |\n| `onMemberAdd` | A user joins a guild. | `GuildMemberAdd` | `user`, `guildId` |\n| `onReactionAdd` | A reaction is added to a message. | `MessageReaction` | `userId`, `messageId`, `emoji` |\n\n## Example: Handling Multiple Events\n\n```swift\nlet bot = DiscordBot(token: \"...\", intents: .default | .messageContent)\n\nbot.onReady { ready in\n    print(\"Logged in as \\(ready.user.username)\")\n}\n\nbot.onMessage { message in\n    if message.content == \"!hello\" {\n        try await message.reply(\"Hello there!\")\n    }\n}\n\ntry await bot.start()\n```\n\n> **Next:** [Messages](./messages)\n"
    },
    {
      "id": "06",
      "filename": "06-messages.md",
      "title": "06 Messages",
      "content": "# Messages\n\nMessages are the primary way users interact with your bot. In SWDCK, the `Message` object contains everything you need to know about a message and provides convenient helpers to respond.\n\n## Receiving a Message\n\nThe `onMessage` handler is triggered whenever a message is sent in a channel your bot can see.\n\n```swift\nbot.onMessage { message in\n    print(\"Author: \\(message.author.username)\")\n    print(\"Content: \\(message.content)\")\n    print(\"Channel ID: \\(message.channelId)\")\n}\n```\n\n### Key Properties\n\nThe `Message` object exposes several important fields:\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `id` | `String` | The unique ID of the message. |\n| `content` | `String` | The text content of the message. |\n| `author` | `DiscordUser` | The user who sent the message. |\n| `channelId` | `String` | The ID of the channel where it was sent. |\n| `guildId` | `String?` | The ID of the guild (if not a DM). |\n| `timestamp` | `String` | When the message was sent (ISO8601). |\n\n---\n\n## Best Practice: Ignoring Bots\n\nYou should almost always ignore messages sent by bots (including your own bot) to prevent infinite loops.\n\n```swift\nbot.onMessage { message in\n    guard !message.author.bot else { return }\n    // Your logic here\n}\n```\n\n---\n\n## Sending Messages\n\nYou can send messages using the `DiscordBot` instance or by responding to an existing message.\n\n### Sending to a Specific Channel\nUse `bot.sendMessage(to:content:)` to send a message to any channel if you have the ID.\n\n```swift\ntry await bot.sendMessage(to: \"123456789\", content: \"Hello from the bot!\")\n```\n\n### Replying to a Message\nThe `message.reply(_:)` helper sends a message back to the same channel and creates a Discord-style reply (referencing the original message).\n\n```swift\nbot.onMessage { message in\n    if message.content.contains(\"ping\") {\n        try await message.reply(\"Pong!\")\n    }\n}\n```\n\n### Plain Response\nIf you want to send a message back to the same channel without the \"reply\" reference, use `message.respond(_:)`.\n\n```swift\ntry await message.respond(\"I'm responding to you!\")\n```\n\n---\n\n## Editing & Deleting\n\n### Editing a Message\nYou can edit a message the bot has sent using its `id`.\n\n```swift\nlet sentMessage = try await bot.sendMessage(to: \"...\", content: \"Original text\")\ntry await bot.editMessage(channelId: sentMessage.channelId, messageId: sentMessage.id, content: \"Edited text!\")\n```\n\n### Deleting a Message\nLikewise, you can delete a message using its `id`.\n\n```swift\ntry await bot.deleteMessage(channelId: message.channelId, messageId: message.id)\n```\n\n---\n\n## Files & Attachments\n\n> \u26a0\ufe0f **Needs verification:** SWDCK supports sending files via `sendComponentsV2Message` using `DiscordFileUpload` objects.\n\n```swift\nlet file = DiscordFileUpload(filename: \"hello.txt\", data: \"Hello World\".data(using: .utf8)!)\ntry await bot.sendComponentsV2Message(to: message.channelId, components: [], attachments: [file])\n```\n\n> **Next:** [Embeds](./embeds)\n"
    },
    {
      "id": "07",
      "filename": "07-embeds.md",
      "title": "07 Embeds",
      "content": "# Embeds\n\nEmbeds allow you to send rich, formatted content that looks more professional than plain text. They are perfect for status reports, help menus, and server logs.\n\n## Using `EmbedBuilder`\n\nSWDCK provides a convenient `EmbedBuilder` to construct complex embeds step by step.\n\n```swift\nvar builder = EmbedBuilder()\nbuilder.setTitle(\"Server Statistics\")\nbuilder.setDescription(\"Current performance metrics for the bot.\")\nbuilder.setColor(0x00ff00) // Green\nbuilder.addField(name: \"Uptime\", value: \"3 days, 4 hours\", inline: true)\nbuilder.addField(name: \"Guilds\", value: \"150\", inline: true)\nbuilder.setFooter(\"Last updated at 12:00 PM\")\n\nlet embed = builder.build()\n```\n\n## Field Reference Table\n\n| Property | Method in Builder | Description | Limit |\n|----------|-------------------|-------------|-------|\n| `title` | `setTitle()` | The bold title at the top. | 256 chars |\n| `description` | `setDescription()` | The main body text. | 4096 chars |\n| `url` | `setURL()` | Makes the title a clickable link. | - |\n| `color` | `setColor()` | The colored strip on the left (Integer hex). | - |\n| `fields` | `addField()` | Key-value pairs of data. | 25 fields |\n| `footer` | `setFooter()` | Small text at the bottom. | 2048 chars |\n| `author` | `setAuthor()` | Small header with name and icon. | 256 chars |\n| `image` | `setImage()` | A large image at the bottom. | - |\n| `thumbnail` | `setThumbnail()` | A small image in the top-right. | - |\n| `timestamp` | `setTimestamp()` | An ISO8601 timestamp in the footer. | - |\n\n---\n\n## Sending an Embed\n\nYou can send an embed as part of a message payload.\n\n### In a new message\n```swift\nlet embed = EmbedBuilder()\n    .setTitle(\"Hello!\")\n    .build()\n\nlet payload = SendMessagePayload(content: \"Check this out:\", embeds: [embed])\ntry await bot.sendMessage(to: channelId, payload: payload)\n```\n\n### In a reply\n```swift\nbot.onMessage { message in\n    if message.content == \"!stats\" {\n        let embed = EmbedBuilder()\n            .setTitle(\"Stats\")\n            .setDescription(\"Looking good!\")\n            .build()\n        \n        // You can pass an array of embeds to the payload\n        let payload = SendMessagePayload(embeds: [embed])\n        try await bot.rest.sendMessage(channelId: message.channelId, payload: payload)\n    }\n}\n```\n\n---\n\n## Common Mistakes\n\n- **Invalid Colors**: Colors must be integers. Use hex literals like `0xFF0000` for red.\n- **Empty Fields**: Fields must have both a `name` and a `value` that are non-empty strings.\n- **Character Limits**: Discord strictly enforces character limits. If you exceed them, the message will fail to send.\n\n> **Next:** [Slash Commands](./slash-commands)\n"
    },
    {
      "id": "08",
      "filename": "08-slash-commands.md",
      "title": "08 Slash Commands",
      "content": "# Slash Commands\n\nSlash commands are the modern, recommended way for users to interact with your bot. They provide a native UI in Discord, auto-completion, and better discoverability.\n\n## Registering a Slash Command\n\nRegister commands directly on your `DiscordBot` instance. By default, SWDCK will sync these commands globally when the bot starts.\n\n```swift\nbot.slashCommand(\"ping\", description: \"Get a pong back!\") { interaction in\n    try await interaction.respond(\"Pong! \ud83c\udfd3\")\n}\n```\n\n### Command Options\n\nYou can define parameters (options) that users can fill out.\n\n```swift\nlet options = [\n    CommandOption(name: \"name\", description: \"Who should I greet?\", type: .string, required: true)\n]\n\nbot.slashCommand(\"greet\", description: \"Say hello to someone\", options: options) { interaction in\n    let name = interaction.option(\"name\")?.stringValue ?? \"there\"\n    try await interaction.respond(\"Hello, \\(name)!\")\n}\n```\n\n## Handling Interactions\n\nWhen a user runs a slash command, the `handler` closure is executed. The `Interaction` object provides everything you need to know about the command usage.\n\n### Interaction Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `user` | `DiscordUser?` | The user who ran the command (in DMs). |\n| `member` | `GuildMember?` | The member who ran the command (in a guild). |\n| `channelId` | `String?` | Where the command was run. |\n| `token` | `String` | The interaction token (used for verification/follow-ups). |\n\n---\n\n## Responding to Interactions\n\nYou have several ways to respond to a slash command.\n\n### Immediate Response\nSends a message that is visible to everyone (or just the user).\n```swift\ntry await interaction.respond(\"Command received!\")\n```\n\n### Ephemeral Responses\nOnly the user who ran the command can see these.\n```swift\ntry await interaction.respond(\"Shh, this is a secret.\", ephemeral: true)\n```\n\n### Deferring a Response\nIf your command takes longer than 3 seconds to process, you **must** defer the response. This shows a \"Thinking...\" state in Discord.\n```swift\ntry await interaction.defer_()\n// Perform long task...\ntry await interaction.editResponse(\"Finished processing!\")\n```\n\n### Follow-up Messages\nSend additional messages after the initial response.\n```swift\ntry await interaction.respond(\"Success!\")\ntry await interaction.followUp(\"And here is something else.\")\n```\n\n---\n\n## Global vs. Guild Commands\n\n- **Global Commands**: Available in all servers the bot is in and in DMs. (Synced automatically if `commandSyncMode` is `.global`).\n- **Guild Commands**: Available only in a specific server. These update instantly, making them great for development.\n\n> \ud83d\udca1 **Tip:** To clear commands during development, use `try await bot.clearSlashCommands(guildId: \"YOUR_GUILD_ID\")`.\n\n> **Next:** [Components](./components)\n"
    },
    {
      "id": "09",
      "filename": "09-components.md",
      "title": "09 Components",
      "content": "# Components (Buttons, Selects & Modals)\n\nComponents V2 is SWDCK's powerful system for building interactive UIs within Discord messages. This includes buttons, dropdown menus, and pop-up modals.\n\n## Buttons\n\nButtons are the most common component. They can trigger an interaction or open a link.\n\n```swift\nlet button = ComponentV2Button(\n    style: .primary,\n    label: \"Click Me\",\n    customId: \"my_button_id\"\n)\n\nlet actionRow = ComponentV2ActionRow(components: [.button(button)])\ntry await bot.sendComponentsV2Message(to: channelId, components: [.actionRow(actionRow)])\n```\n\n### Button Styles\n| Style | Description |\n|-------|-------------|\n| `.primary` | Blurple (main action). |\n| `.secondary` | Grey (secondary action). |\n| `.success` | Green (positive outcome). |\n| `.danger` | Red (destructive action). |\n| `.link` | Grey with a link icon (requires a `url`). |\n\n---\n\n## Select Menus\n\nSelect menus allow users to choose from a list of options.\n\n```swift\nlet select = ComponentV2StringSelect(\n    customId: \"color_picker\",\n    options: [\n        ComponentV2SelectOption(label: \"Red\", value: \"red\"),\n        ComponentV2SelectOption(label: \"Blue\", value: \"blue\")\n    ],\n    placeholder: \"Choose a color\"\n)\n\nlet actionRow = ComponentV2ActionRow(components: [.stringSelect(select)])\ntry await bot.sendComponentsV2Message(to: channelId, components: [.actionRow(actionRow)])\n```\n\n---\n\n## Handling Component Interactions\n\nWhen a user clicks a button or selects an option, it triggers an interaction. Listen for these using `onInteraction`.\n\n```swift\nbot.onInteraction { interaction in\n    guard interaction.type == .messageComponent else { return }\n    \n    if interaction.data?.customId == \"my_button_id\" {\n        try await interaction.respond(\"You clicked the button!\")\n    }\n}\n```\n\n---\n\n## Modals\n\nModals are pop-up forms that can gather text input from the user.\n\n### Presenting a Modal\nModals must be sent as a response to an interaction (e.g., a button click or a slash command).\n\n```swift\nbot.slashCommand(\"report\", description: \"Report an issue\") { interaction in\n    let input = ComponentV2TextInput(\n        customId: \"issue_desc\",\n        style: .paragraph,\n        placeholder: \"Describe the problem...\"\n    )\n    \n    let container = ComponentV2Label(\n        label: \"Issue Description\",\n        component: .textInput(input)\n    )\n    \n    try await interaction.presentModal(\n        customId: \"report_modal\",\n        title: \"Submit Report\",\n        components: [container]\n    )\n}\n```\n\n### Handling Modal Submission\n\n```swift\nbot.onInteraction { interaction in\n    guard interaction.type == .modalSubmit else { return }\n    \n    if interaction.data?.customId == \"report_modal\" {\n        let description = interaction.data?.submittedValue(customId: \"issue_desc\")?.stringValue\n        try await interaction.respond(\"Thank you for your report: \\(description ?? \"N/A\")\", ephemeral: true)\n    }\n}\n```\n\n> **Next:** [Permissions & Roles](./permissions-roles)\n"
    },
    {
      "id": "10",
      "filename": "10-permissions-roles.md",
      "title": "10 Permissions Roles",
      "content": "# Permissions & Roles\n\nDiscord uses a bitwise permission system to control what users and bots can do. In SWDCK, permissions are represented as strings containing large integers to maintain precision.\n\n## Roles\n\nA `GuildRole` object contains the name, color, and permissions for a specific role in a server.\n\n```swift\nbot.onGuildCreate { guild in\n    for role in guild.roles ?? [] {\n        print(\"Role: \\(role.name), Color: \\(role.color)\")\n    }\n}\n```\n\n### Key Role Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `id` | `String` | Unique ID of the role. |\n| `name` | `String` | Role name. |\n| `color` | `Int` | Integer color (e.g., `0x3498db`). |\n| `permissions` | `String` | Bitwise permission flags as a string. |\n| `position` | `Int` | Ranking in the role hierarchy. |\n\n---\n\n## Checking Permissions\n\nTo check if a member has a specific permission, you'll need to convert the permission string to a numerical value and use bitwise operations.\n\n```swift\n// Common Permission Constants (Bit Positions)\nenum Permission: UInt64 {\n    case administrator = 0x8\n    case manageChannels = 0x10\n    case kickMembers = 0x2\n    case banMembers = 0x4\n}\n\nfunc hasPermission(_ member: GuildMember, permission: Permission) -> Bool {\n    guard let permString = member.permissions,\n          let permValue = UInt64(permString) else { return false }\n    \n    return (permValue & permission.rawValue) != 0\n}\n```\n\n> \ud83d\udca1 **Tip:** Detailed permission bit definitions can be found in the [Discord API Documentation](https://discord.com/developers/docs/topics/permissions#permissions-bitwise-value).\n\n---\n\n## Managing Roles\n\n### Creating a Role\n```swift\ntry await bot.createGuildRole(guildId: \"...\", name: \"New Role\", color: 0xFF0000)\n```\n\n### Modifying a Role\n```swift\ntry await bot.modifyGuildRole(guildId: \"...\", roleId: \"...\", name: \"Updated Name\")\n```\n\n### Assigning a Role to a Member\n```swift\ntry await bot.addGuildMemberRole(guildId: \"...\", userId: \"...\", roleId: \"...\")\n```\n\n### Removing a Role\n```swift\ntry await bot.removeGuildMemberRole(guildId: \"...\", userId: \"...\", roleId: \"...\")\n```\n\n> **Next:** [Guilds, Channels & Members](./guilds-channels-members)\n"
    },
    {
      "id": "11",
      "filename": "11-guilds-channels-members.md",
      "title": "11 Guilds Channels Members",
      "content": "# Guilds, Channels & Members\n\nUnderstanding how Discord structures servers (Guilds) and the entities within them is key to building advanced bots.\n\n## Guilds (Servers)\n\nA `Guild` represents a Discord server. It is the top-level container for channels, members, and roles.\n\n```swift\nbot.onGuildCreate { guild in\n    print(\"Available in guild: \\(guild.name) (\\(guild.id))\")\n    print(\"Member count: \\(guild.memberCount ?? 0)\")\n}\n```\n\n### Common Guild Operations\n- **Fetch a Guild**: `try await bot.getGuild(id: \"...\")`\n- **Leave a Guild**: `try await bot.leaveGuild(id: \"...\")`\n- **Get Audit Logs**: `try await bot.getGuildAuditLog(guildId: \"...\")`\n\n---\n\n## Channels\n\nChannels are where the action happens. They can be text-based, voice-based, or categories.\n\n### Channel Types\n| Type | Description |\n|------|-------------|\n| `.guildText` | Standard text channel. |\n| `.guildVoice` | Standard voice channel. |\n| `.guildCategory` | A folder-like container for other channels. |\n| `.guildAnnouncement` | News channel. |\n| `.publicThread` / `.privateThread` | Threads within a text channel. |\n\n### Channel Operations\n- **Fetch a Channel**: `try await bot.getChannel(id: \"...\")`\n- **Modify a Channel**: `try await bot.modifyChannel(id: \"...\", name: \"new-name\")`\n- **Delete a Channel**: `try await bot.deleteChannel(id: \"...\")`\n\n---\n\n## Members vs. Users\n\nIn SWDCK (and Discord), there is a distinction between a **User** and a **Member**.\n\n- **`DiscordUser`**: Represents a global Discord user (ID, username, avatar).\n- **`GuildMember`**: Represents a user *specific to a server* (nickname, joined date, roles).\n\n```swift\nbot.onMessage { message in\n    let user = message.author       // Global user info\n    let member = message.member    // Server-specific info (roles, nick)\n    \n    print(\"\\(user.username) is also known as \\(member?.nick ?? \"none\") here.\")\n}\n```\n\n### Member Operations\n- **Fetch a Member**: `try await bot.getGuildMember(guildId: \"...\", userId: \"...\")`\n- **Modify a Member**: `try await bot.modifyGuildMember(guildId: \"...\", userId: \"...\", nick: \"New Nick\")`\n- **Kick a Member**: `try await bot.removeGuildMember(guildId: \"...\", userId: \"...\")`\n- **Ban a Member**: `try await bot.createGuildBan(guildId: \"...\", userId: \"...\")`\n\n---\n\n## Hierarchy Recap\n\n1. **Guild**: The server container.\n2. **Channel**: A specific place for messaging or talking.\n3. **Role**: A set of permissions.\n4. **Member**: A user within a guild, assigned one or more roles.\n\n> **Next:** [Error Handling](./error-handling)\n"
    },
    {
      "id": "12",
      "filename": "12-error-handling.md",
      "title": "12 Error Handling",
      "content": "# Error Handling\n\nNetwork requests can fail, permissions can be missing, and Discord can apply rate limits. SWDCK uses Swift's error handling system (`throws`) to help you catch and manage these situations.\n\n## `DiscordError`\n\nMost failures in SWDCK throw a `DiscordError` enum. This includes both local validation errors and errors returned by the Discord API.\n\n### Common Error Cases\n\n| Case | Description |\n|------|-------------|\n| `.invalidToken` | Your bot token is wrong or expired. |\n| `.rateLimited(retryAfter:)` | You are sending requests too fast. Wait `retryAfter` seconds. |\n| `.missingPermissions(endpoint:)` | The bot doesn't have the permission required for that action. |\n| `.resourceNotFound(endpoint:)` | The ID you provided (channel, user, etc.) doesn't exist. |\n| `.decodingFailed(type:underlying:)` | Discord sent unexpected data that the library couldn't parse. |\n\n---\n\n## Handling Errors in Async/Await\n\nSince most methods are `async`, you should wrap them in `do-catch` blocks.\n\n```swift\ndo {\n    try await bot.sendMessage(to: \"invalid_id\", content: \"Hello\")\n} catch let error as DiscordError {\n    switch error {\n    case .missingPermissions:\n        print(\"I don't have permission to send messages there!\")\n    case .resourceNotFound:\n        print(\"That channel doesn't exist.\")\n    default:\n        print(\"Discord Error: \\(error.localizedDescription)\")\n    }\n} catch {\n    print(\"Unexpected error: \\(error)\")\n}\n```\n\n---\n\n## Handling Rate Limits\n\nSWDCK does not automatically retry rate-limited requests yet. When you receive a `.rateLimited` error, it is your responsibility to wait and retry if desired.\n\n```swift\nfunc safeSend(_ content: String, to channelId: String) async {\n    do {\n        try await bot.sendMessage(to: channelId, content: content)\n    } catch DiscordError.rateLimited(let retryAfter) {\n        print(\"Rate limited! Retrying in \\(retryAfter) seconds...\")\n        try? await Task.sleep(nanoseconds: UInt64(retryAfter * 1_000_000_000))\n        await safeSend(content, to: channelId) // Recursive retry\n    } catch {\n        print(\"Failed to send: \\(error)\")\n    }\n}\n```\n\n---\n\n## Gateway Disconnections\n\nIf the WebSocket connection drops, SWDCK will attempt to reconnect automatically. You can monitor these events by listening for `onGatewayDisconnect` (if implemented) or by checking the bot's logs.\n\n> \ud83d\udca1 **Tip:** Always check your bot's logs if it suddenly stops responding. SWDCK logs detailed error information to the console.\n\n> **Next:** [Configuration & Best Practices](./configuration-best-practices)\n"
    },
    {
      "id": "13",
      "filename": "13-configuration-best-practices.md",
      "title": "13 Configuration Best Practices",
      "content": "# Configuration & Best Practices\n\nBuilding a reliable bot requires more than just knowing the API. Following these best practices will help you create a stable and secure application.\n\n## Storing Your Token Safely\n\n**Never hardcode your bot token.** If you push your code to GitHub, anyone can see it.\n\n### Recommended: Environment Variables\nUse a library like `SwiftDotenv` or simply read from `ProcessInfo`.\n\n```swift\nlet env = ProcessInfo.processInfo.environment\nguard let token = env[\"DISCORD_TOKEN\"] else {\n    fatalError(\"Missing DISCORD_TOKEN in environment\")\n}\nlet bot = DiscordBot(token: token, ...)\n```\n\n---\n\n## Command Sync Mode\n\nSWDCK offers two modes for syncing slash commands:\n- `.global` (Default): Syncs all registered `slashCommand`s to Discord globally. Note that global updates can take up to an hour to propagate.\n- `.manual`: You manually control when and where commands are synced using `syncCommandsIfNeeded` or `syncCommands`.\n\n---\n\n## Sharding\n\nSharding is a way to split your bot's connection across multiple WebSocket connections. This is required by Discord for bots in 2,500+ servers.\n**SWDCK handles sharding automatically.** When you call `bot.start()`, the library requests the recommended number of shards from Discord and scales accordingly.\n\n---\n\n## Performance & Concurrency\n\n### Use Actors for State\nIf your bot needs to keep track of data (like a simple leveling system or a game state), use Swift **Actors** to ensure thread safety.\n\n```swift\nactor BotStats {\n    var messagesSeen = 0\n    func increment() { messagesSeen += 1 }\n}\n```\n\n### Don't Block the Gateway\nThe gateway connection is sensitive. Avoid running long-running, CPU-intensive tasks directly in an event handler. Instead, use a background `Task`.\n\n```swift\nbot.onMessage { message in\n    Task.detached(priority: .background) {\n        // Perform heavy work here\n    }\n}\n```\n\n---\n\n## Logging\n\nSWDCK uses a built-in logging system. You can see detailed information about the Gateway connection and REST requests in your console. \n\n> \ud83d\udca1 **Tip:** Pay attention to logs starting with `[SWDCK]` as they often contain clues about why a connection failed or why a command wasn't registered.\n\n---\n\n## Summary Checklist\n\n- [ ] Token is stored in a secure environment variable.\n- [ ] Required Gateway Intents are enabled in the Developer Portal.\n- [ ] Message handlers ignore other bots (`!message.author.bot`).\n- [ ] Long-running tasks are moved to background tasks.\n- [ ] Errors are properly handled with `do-catch` blocks.\n\n> **Next:** [Full Example Bot](./example-bot)\n"
    },
    {
      "id": "14",
      "filename": "14-example-bot.md",
      "title": "14 Example Bot",
      "content": "# Full Example Bot\n\nThis comprehensive example combines everything we've learned: events, slash commands, embeds, and components.\n\n```swift\nimport SWDCK\nimport Foundation\n\n@main\nstruct MyBot {\n    static func main() async throws {\n        // 1. Setup\n        let bot = DiscordBot(\n            token: \"YOUR_TOKEN\",\n            intents: .default | .messageContent | .guildMembers\n        )\n\n        // 2. Logging On Ready\n        bot.onReady { ready in\n            print(\"\ud83d\ude80 \\(ready.user.username) is online!\")\n        }\n\n        // 3. Simple Message Response\n        bot.onMessage { message in\n            guard !message.author.bot else { return }\n            \n            if message.content == \"!hello\" {\n                try await message.reply(\"Hello from the full example!\")\n            }\n        }\n\n        // 4. Slash Command with Embed & Button\n        let welcomeOptions = [\n            CommandOption(name: \"user\", description: \"The user to welcome\", type: .user, required: true)\n        ]\n        \n        bot.slashCommand(\"welcome\", description: \"Send a fancy welcome message\", options: welcomeOptions) { interaction in\n            let targetUser = interaction.option(\"user\")?.userValue\n            let username = targetUser?.username ?? \"unknown\"\n            \n            // Build a fancy embed\n            let embed = EmbedBuilder()\n                .setTitle(\"Welcome to the Server!\")\n                .setDescription(\"We are glad to have you here, \\(username)!\")\n                .setColor(0x5865F2) // Blurple\n                .setThumbnail(targetUser?.avatarURL?.absoluteString ?? \"\")\n                .build()\n            \n            // Add a button\n            let button = ComponentV2Button(style: .link, label: \"View Rules\", url: \"https://example.com/rules\")\n            let row = ComponentV2ActionRow(components: [.button(button)])\n            \n            // Respond\n            try await interaction.respond(\n                SendMessagePayload(embeds: [embed], components: [.actionRow(row)])\n            )\n        }\n\n        // 5. Moderation Command (Kick)\n        let kickOptions = [\n            CommandOption(name: \"user\", description: \"Member to kick\", type: .user, required: true),\n            CommandOption(name: \"reason\", description: \"Why?\", type: .string, required: false)\n        ]\n        \n        bot.slashCommand(\"kick\", description: \"Kick a member\", options: kickOptions) { interaction in\n            guard let guildId = interaction.guildId,\n                  let userId = interaction.option(\"user\")?.userValue?.id else { return }\n            \n            let reason = interaction.option(\"reason\")?.stringValue\n            \n            do {\n                try await bot.removeGuildMember(guildId: guildId, userId: userId, reason: reason)\n                try await interaction.respond(\"Successfully kicked the user.\", ephemeral: true)\n            } catch {\n                try await interaction.respond(\"Failed to kick: \\(error.localizedDescription)\", ephemeral: true)\n            }\n        }\n\n        // 6. Connect\n        try await bot.start()\n    }\n}\n```\n\n## What this bot does:\n1. **Identifies itself**: Logs to your console when it successfully connects.\n2. **Responds to `!hello`**: A classic text-based command.\n3. **`/welcome`**: Uses a **Slash Command**, creates a high-quality **Embed**, and attaches an **Action Row** with a **Button**.\n4. **`/kick`**: Shows how to use interaction options to perform **Moderation** actions and handle errors specifically for that user.\n\n---\n\n## Running the Example\n1. Add SWDCK to your project using SPM.\n2. Ensure `MESSAGE_CONTENT` and `GUILD_MEMBERS` intents are enabled in the portal.\n3. Replace `\"YOUR_TOKEN\"` with your actual token.\n4. Build and Run! \n\n> **Next:** [API Reference](./api-reference)\n"
    },
    {
      "id": "15",
      "filename": "15-api-reference.md",
      "title": "15 Api Reference",
      "content": "# API Reference\n\nThis page provides a technical overview of the primary classes and methods available in SWDCK.\n\n---\n\n## `DiscordBot`\n\nThe main entry point and orchestrator.\n\n### Initializer\n- `init(token: String, intents: GatewayIntents = .default, commandSyncMode: CommandSyncMode = .global)`: Creates a new bot instance.\n\n### Methods\n- `start() async throws`: Initializes the Gateway connection and starts the bot.\n- `onReady(handler: @escaping (ReadyData) -> Void)`: Registers a handler for when the bot comes online.\n- `onMessage(handler: @escaping (Message) -> Void)`: Registers a handler for new messages.\n- `onInteraction(handler: @escaping (Interaction) -> Void)`: Registers a generic interaction handler.\n- `slashCommand(_ name: String, description: String, options: [CommandOption] = [], handler: @escaping (Interaction) -> Void)`: Registers a slash command.\n\n---\n\n## `Message`\n\nRepresents a Discord message.\n\n### Properties\n- `id: String`: Unique ID.\n- `content: String`: Text content.\n- `author: DiscordUser`: User who sent the message.\n- `channelId: String`: ID of the channel.\n- `member: GuildMember?`: Member info (if in a guild).\n\n### Methods\n- `reply(_ content: String) async throws -> Message`: Sends a reply referencing this message.\n- `respond(_ content: String) async throws -> Message`: Sends a message back to the same channel.\n\n---\n\n## `Interaction`\n\nRepresents an interaction (slash command or component).\n\n### Properties\n- `id: String`: Unique ID.\n- `type: InteractionType`: `.applicationCommand`, `.messageComponent`, etc.\n- `data: InteractionData?`: Payload containing command name, options, or custom ID.\n\n### Methods\n- `respond(_ content: String, ephemeral: Bool = false) async throws`: Sends an immediate response.\n- `defer_() async throws`: Defers the response (shows \"Thinking...\").\n- `editResponse(_ content: String) async throws`: Updates the deferred or original response.\n- `presentModal(customId: String, title: String, components: [ComponentV2Node]) async throws`: Shows a pop-up modal.\n\n---\n\n## `EmbedBuilder`\n\nHelpful builder for creating rich embeds.\n\n### Methods\n- `setTitle(_ title: String) -> EmbedBuilder`\n- `setDescription(_ description: String) -> EmbedBuilder`\n- `setColor(_ color: Int) -> EmbedBuilder`\n- `addField(name: String, value: String, inline: Bool = false) -> EmbedBuilder`\n- `build() -> Embed`: Returns the final `Embed` object.\n\n---\n\n> \ud83d\udca1 **Notice:** For a complete list of all models and REST methods, please refer to the source code or use Xcode's **Quick Help (Opt+Click)** feature.\n"
    },
    {
      "id": "16",
      "filename": "16-faq-troubleshooting.md",
      "title": "16 Faq Troubleshooting",
      "content": "# FAQ & Troubleshooting\n\nEncountering issues? Check here first for solutions to common problems.\n\n## Frequently Asked Questions\n\n### \u2753 My bot is online, but `onMessage` never fires.\n**Solution:** You likely haven't enabled the **Message Content Intent**.\n1. Go to the [Discord Developer Portal](https://discord.com/developers/applications).\n2. Select your app -> **Bot**.\n3. Enable **Message Content Intent**.\n4. In your code, ensure you include `.messageContent` in your `intents`:\n   ```swift\n   let bot = DiscordBot(token: \"...\", intents: .default | .messageContent)\n   ```\n\n### \u2753 I registered a slash command, but it's not showing up in Discord.\n**Solution:** Global slash commands can take up to **one hour** to propagate to all servers. For instant testing, use **Guild Commands**:\n```swift\n// This updates instantly for the specific guild\ntry await bot.syncCommands(to: \"your_guild_id\")\n```\nAlso, ensure the bot was invited with the `applications.commands` scope.\n\n### \u2753 I get the error: \"Interaction already acknowledged\".\n**Solution:** You are trying to respond to an interaction that has already been responded to or deferred. You can only send one \"initial\" response. Use `followUp()` or `editResponse()` for subsequent updates.\n\n---\n\n## Troubleshooting Tools\n\n### Enable Detailed Logging\nSWDCK logs important events to the console by default. If you are having connection issues, look for lines starting with `[SWDCK][Gateway]`.\n\n### Common Gateway Close Codes\n| Code | Meaning | Action |\n|------|---------|--------|\n| 4004 | Authentication failed. | Your token is invalid. Reset it in the portal. |\n| 4014 | Disallowed intent. | You requested an intent (like `guildMembers`) that isn't enabled in the portal. |\n| 4010 | Invalid Shard. | You are trying to use more shards than allowed. (Usually handled automatically by SWDCK). |\n\n---\n\n## Still having trouble?\n\nIf your issue isn't listed here:\n1. Check the [Samples](./example-bot) to see if your setup matches.\n2. Open an issue on the [GitHub Repository](https://github.com/PRATIKK0709/SWDCK--SwiftDiscKit/issues).\n3. Provide your Swift version, platform (macOS/iOS), and any error logs from the console.\n"
    },
    {
      "id": "17",
      "filename": "17-changelog.md",
      "title": "17 Changelog",
      "content": "# Changelog\n\nAll notable changes to the SWDCK library will be documented here.\n\n## [1.0.0] - 2024-02-19\n\nThis is the initial documentation release, focusing on providing a comprehensive guide for all core features.\n\n### Added\n- **Core Engine**: Stable Gateway and REST API implementation.\n- **Modern Concurrency**: Full `async/await` support throughout the library.\n- **Components V2**: Support for buttons, select menus, and modals.\n- **Slash Commands**: Automated registration and easy interaction handling.\n- **Type Safety**: Comprehensive models for most Discord API v10 entities.\n- **Embed Builder**: A convenient DSL-like builder for rich message content.\n\n### Fixed\n- Fixed heartbeat jitter on high-latency connections.\n- Improved decoding reliability for optional fields in `Guild` and `Member` models.\n\n---\n\n> \ud83d\udca1 **Note:** Future updates will follow [Semantic Versioning](https://semver.org/).\n"
    },
    {
      "id": "18",
      "filename": "18-contributing-license.md",
      "title": "18 Contributing License",
      "content": "# Contributing & License\n\nSWDCK is an open-source project, and we welcome contributions from the community!\n\n## License\n\nSWDCK is released under the **MIT License**.\n\n```text\nCopyright (c) 2024 PRATIKK0709\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n...\n```\n\nYou are free to use, modify, and distribute the library in both personal and commercial projects.\n\n---\n\n## Contributing\n\n### How to Help\n- **Reporting Bugs**: Open an issue on GitHub with steps to reproduce the bug.\n- **Feature Requests**: Have an idea for a new feature? Open an issue to discuss it.\n- **Code Contributions**: \n    1. Fork the repo.\n    2. Create a feature branch.\n    3. Ensure your code follows Swift API Design Guidelines.\n    4. Submit a Pull Request.\n\n### Code Style\nWe follow standard Swift formatting. Please ensure your code is readable and includes basic DocC comments for public methods.\n\n---\n\n## Security\n\nIf you discover a security vulnerability, please do NOT open a public issue. Instead, contact the developer directly or use the \"Report security vulnerability\" feature on GitHub.\n\n---\n\n**Thank you for using SWDCK!**\n"
    }
  ]
}